import argparse
from pathlib import Path
import sys
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

def find_col(df, name):
    name = name.lower()
    for c in df.columns:
        if c.lower() == name:
            return c
    return None

def coerce_datetime(s):
    return pd.to_datetime(s, errors="coerce", infer_datetime_format=True, utc=False)

def main():
    ap = argparse.ArgumentParser(description="2019 weather vs pedestrian analysis with correlation matrix.")
    ap.add_argument("data_path", help="CSV/Parquet/Feather/Excel with counts and weather columns")
    ap.add_argument("--outdir", default=".", help="Directory to save outputs")
    ap.add_argument("--location", default="Brooklyn Bridge",
                    help="Location name to filter (if the dataset includes multiple locations)")
    args = ap.parse_args()

    in_path = Path(args.data_path)
    outdir = Path(args.outdir); outdir.mkdir(parents=True, exist_ok=True)

    ext = in_path.suffix.lower()
    if ext == ".csv":
        df = pd.read_csv(in_path)
    elif ext == ".parquet":
        df = pd.read_parquet(in_path)
    elif ext == ".feather":
        import pyarrow.feather as feather
        df = feather.read_feather(in_path)
    elif ext in [".xlsx", ".xls"]:
        df = pd.read_excel(in_path)
    else:
        print(f"Unsupported file extension: {ext}", file=sys.stderr); sys.exit(2)

    # Resolve key columns
    col_time = find_col(df, "Hour_beginning")
    col_total = find_col(df, "Pedestrians")
    col_loc = find_col(df, "Location")
    col_ws = find_col(df, "Weather_summary")
    col_temp = find_col(df, "Temperature")
    col_precip = find_col(df, "Precipitation")

    if col_time is None or col_total is None:
        print("Required columns not found (Hour_beginning, Pedestrians).", file=sys.stderr)
        sys.exit(2)

    # Parse time and derive year/hour
    ts = coerce_datetime(df[col_time])
    df = df.assign(__ts=ts)
    df = df[df["__ts"].notna()].copy()
    df["Year"] = df["__ts"].dt.year
    df["Hour"] = df["__ts"].dt.hour

    # Filter to 2019
    df2019 = df[df["Year"] == 2019].copy()

    # Optional: filter to location
    if col_loc and args.location:
        df2019 = df2019[df2019[col_loc].astype(str).str.strip().str.lower() == args.location.strip().lower()]

    # Sort by Weather_summary for quick inspection
    if col_ws is None:
        # make a placeholder if not present
        df2019["Weather_summary"] = "Unknown"
        col_ws = "Weather_summary"
    df2019_sorted = df2019.sort_values(by=col_ws, kind="stable")

    # Aggregate by Weather_summary
    agg = (df2019_sorted.groupby(col_ws)[col_total]
           .agg(total="sum", mean="mean", median="median", n="count")
           .sort_index())
    agg.to_csv(outdir / "weather2019_by_summary.csv", index=True)

    # Build correlation matrix on numeric columns of interest
    # Select a conservative set to avoid non-numeric errors
    numeric_cols = []
    for cand in [col_total, col_temp, col_precip, "Hour"]:
        if cand and cand in df2019_sorted.columns:
            if pd.api.types.is_numeric_dtype(df2019_sorted[cand]):
                numeric_cols.append(cand)
    if not numeric_cols:
        # still produce an empty CSV to signal no numeric variables beyond Pedestrians
        (outdir / "weather2019_corr.csv").write_text("")
    else:
        corr = df2019_sorted[numeric_cols].corr(method="pearson")
        corr.to_csv(outdir / "weather2019_corr.csv", index=True)

        # Plot heatmap (matplotlib only)
        fig, ax = plt.subplots(figsize=(6,5))
        cax = ax.imshow(corr.values, aspect='auto')
        ax.set_xticks(range(len(corr.columns)))
        ax.set_yticks(range(len(corr.index)))
        ax.set_xticklabels(corr.columns, rotation=45, ha='right')
        ax.set_yticklabels(corr.index)
        ax.set_title("Correlation Matrix (2019)")
        fig.colorbar(cax, ax=ax, fraction=0.046, pad=0.04)
        fig.tight_layout()
        fig.savefig(outdir / "weather2019_corr.png", dpi=150)
        plt.close(fig)

    print(f"Saved: {outdir/'weather2019_by_summary.csv'}")
    if (outdir / 'weather2019_corr.csv').exists():
        print(f"Saved: {outdir/'weather2019_corr.csv'}, {outdir/'weather2019_corr.png'}")

if __name__ == "__main__":
    main()
